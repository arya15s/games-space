<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Game Space</title>
  <style>
    :root {
      --main-bg: #1e1f26;
      --accent: #ffb347;
      --cube-bg: #23243a;
      --cube-hover: #ffb347;
      --cube-text: #fff;
      --profile-bg: #2d2e3e;
      --loading-bar: #2ecc40;
      --loading-bg: #33344a;
      --title-green: #2ecc40;
    }
    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      background: var(--main-bg);
      color: #fff;
      min-height: 100vh;
      overflow-x: hidden;
    }
    .loading-screen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #1e1f26;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      transition: opacity 0.7s;
    }
    .loading-img {
      width: 120px;
      margin-bottom: 30px;
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
    .loading-bar-bg {
      width: 320px;
      height: 18px;
      background: var(--loading-bg);
      border-radius: 10px;
      overflow: hidden;
      margin-top: 30px;
    }
    .loading-bar {
      height: 100%;
      width: 0%;
      background: var(--loading-bar);
      border-radius: 10px;
      transition: width 0.5s;
    }
    .main-content {
      display: none;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding-bottom: 40px;
    }
    .title {
      font-size: 2.7rem;
      font-weight: bold;
      color: var(--title-green);
      margin-top: 60px;
      margin-bottom: 10px;
      letter-spacing: 2px;
      text-shadow: 0 2px 10px #0008;
    }
    .games-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 32px;
      margin-top: 40px;
      max-width: 700px;
    }
    .game-cube {
      background: var(--cube-bg);
      width: 180px;
      height: 180px;
      border-radius: 18px;
      box-shadow: 0 4px 18px #0005;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--cube-text);
      font-size: 1.1rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.3s, transform 0.2s;
      position: relative;
    }
    .game-cube:hover {
      background: var(--cube-hover);
      color: #23243a;
      transform: translateY(-8px) scale(1.04);
    }
    .game-icon {
      font-size: 2.7rem;
      margin-bottom: 12px;
    }
    .profile-btn {
      position: fixed;
      top: 22px;
      right: 32px;
      background: var(--profile-bg);
      color: var(--accent);
      border: none;
      border-radius: 50%;
      width: 54px;
      height: 54px;
      font-size: 1.7rem;
      cursor: pointer;
      box-shadow: 0 2px 8px #0004;
      transition: background 0.2s;
    }
    .profile-btn:hover {
      background: var(--accent);
      color: var(--profile-bg);
    }
    .profile-modal {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(30,31,38,0.92);
      z-index: 10000;
      align-items: center;
      justify-content: center;
    }
    .profile-content {
      background: var(--profile-bg);
      padding: 32px 38px;
      border-radius: 18px;
      box-shadow: 0 4px 24px #0007;
      color: #fff;
      min-width: 320px;
      text-align: center;
      position: relative;
    }
    .profile-content h2 {
      color: var(--accent);
      margin-bottom: 18px;
    }
    .profile-content label {
      display: block;
      margin: 12px 0 4px;
      font-size: 1.1rem;
    }
    .profile-content input, .profile-content select {
      width: 80%;
      padding: 8px;
      border-radius: 8px;
      border: none;
      margin-bottom: 10px;
      font-size: 1rem;
    }
    .close-profile {
      position: absolute;
      top: 10px;
      right: 18px;
      background: none;
      border: none;
      color: #fff;
      font-size: 1.5rem;
      cursor: pointer;
    }
    .game-options-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(30, 31, 38, 0.92);
      z-index: 10001;
      align-items: center;
      justify-content: center;
    }
    .game-options-content {
      background: var(--profile-bg);
      padding: 32px 38px;
      border-radius: 18px;
      box-shadow: 0 4px 24px #0007;
      min-width: 320px;
      text-align: center;
      position: relative;
    }
    .game-options-content h2 {
      color: var(--accent);
      margin-bottom: 18px;
    }
    .game-options-content button {
      margin: 10px 0;
      padding: 10px 30px;
      font-size: 1.1rem;
      background: var(--accent);
      color: #23243a;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      display: block;
      width: 80%;
      max-width: 260px;
    }
    .game-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(30,31,38,0.97);
      z-index: 10002;
      align-items: center;
      justify-content: center;
    }
    #gameModalContent {
      background: var(--profile-bg);
      padding: 32px 38px;
      border-radius: 18px;
      box-shadow: 0 4px 24px #0007;
      min-width: 320px;
      min-height: 320px;
      text-align: center;
      position: relative;
      max-width: 95vw;
      max-height: 95vh;
      overflow: auto;
    }
    @media (max-width: 700px) {
      .games-grid { gap: 18px; }
      .game-cube { width: 120px; height: 120px; font-size: 0.9rem; }
      .main-content { padding-bottom: 20px; }
      .profile-content { min-width: 90vw; }
      .game-options-content button { width: 90%; }
    }
  </style>
</head>
<body>
  <div class="loading-screen" id="loadingScreen">
    <img class="loading-img" src="https://cdn.pixabay.com/photo/2017/01/31/13/14/ai-2025789_1280.png" alt="Games AI"/>
    <div style="font-size:1.5rem; color:var(--title-green); margin-bottom:10px;">Loading Game Space...</div>
    <div class="loading-bar-bg">
      <div class="loading-bar" id="loadingBar"></div>
    </div>
  </div>
  <div class="main-content" id="mainContent">
    <button class="profile-btn" onclick="openProfile()" title="Profile">üë§</button>
    <div class="title" style="color:var(--title-green);">Welcome to Game Space</div>
    <div class="games-grid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:32px;max-width:700px;margin-top:40px;">
      <div class="game-cube" onclick="openGameOptions('Tic Tac Toe', ['Single Player', 'Multiplayer'])">
        <div class="game-icon">‚ùå‚≠ï</div>
        Tic Tac Toe
      </div>
      <div class="game-cube" onclick="openSlidingPuzzleOptions()">
        <div class="game-icon">üî¢</div>
        <div style="width:100%;display:flex;align-items:center;justify-content:center;">Sliding Number Puzzle</div>
      </div>
      <div class="game-cube" onclick="openMathQuizOptions()">
        <div class="game-icon">‚ûï‚ûñ‚úñÔ∏è</div>
        Math Quiz
      </div>
      <div class="game-cube" onclick="startMemoryGame()" style="margin-top:32px;">
        <div class="game-icon">üÉè</div>
        Memory Game
      </div>
      <div class="game-cube" onclick="startChess()" style="margin-top:32px;">
        <div class="game-icon">‚ôüÔ∏è</div>
        Chess
      </div>
    </div>
  </div>
  <div class="profile-modal" id="profileModal">
    <div class="profile-content">
      <button class="close-profile" onclick="closeProfile()">&times;</button>
      <h2>Profile</h2>
      <form id="profileForm" onsubmit="saveProfile(event)">
        <label for="profileName">Name:</label>
        <input type="text" id="profileName" required />
        <label for="profileAge">Age:</label>
        <input type="number" id="profileAge" min="1" max="120" required />
        <label for="profileGender">Gender:</label>
        <select id="profileGender" required>
          <option value="">Select</option>
          <option value="Male">Male</option>
          <option value="Female">Female</option>
          <option value="Other">Other</option>
        </select>
        <br><br>
        <button type="submit" style="background:var(--accent);color:#23243a;padding:8px 22px;border:none;border-radius:8px;font-size:1.1rem;cursor:pointer;">Save</button>
      </form>
    </div>
  </div>
  <div class="game-options-modal" id="gameOptionsModal" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(30,31,38,0.92);z-index:10001;align-items:center;justify-content:center;">
    <div style="background:var(--profile-bg);padding:32px 38px;border-radius:18px;box-shadow:0 4px 24px #0007;min-width:320px;text-align:center;position:relative;">
      <button style="position:absolute;top:10px;right:18px;background:none;border:none;color:#fff;font-size:1.5rem;cursor:pointer;" onclick="closeGameOptions()">&times;</button>
      <h2 id="gameOptionsTitle" style="color:var(--accent);"></h2>
      <div id="gameOptionsList"></div>
    </div>
  </div>
  <div class="game-modal" id="gameModal" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(30,31,38,0.97);z-index:10002;align-items:center;justify-content:center;">
    <div id="gameModalContent" style="background:var(--profile-bg);padding:32px 38px;border-radius:18px;box-shadow:0 4px 24px #0007;min-width:320px;min-height:320px;text-align:center;position:relative;max-width:95vw;max-height:95vh;overflow:auto;"></div>
  </div>
  <script>
    // Loading screen logic
    let progress = 0;
    const loadingBar = document.getElementById('loadingBar');
    const loadingScreen = document.getElementById('loadingScreen');
    const mainContent = document.getElementById('mainContent');
    let loadingStart = Date.now();
    function fakeLoading() {
      progress += Math.random() * 18 + 7;
      if (progress < 100) {
        loadingBar.style.width = progress + '%';
        setTimeout(fakeLoading, 350);
      } else {
        loadingBar.style.width = '100%';
        // Ensure at least 1 second loading
        let elapsed = Date.now() - loadingStart;
        let wait = Math.max(0, 1000 - elapsed);
        setTimeout(() => {
          loadingScreen.style.opacity = 0;
          setTimeout(() => {
            loadingScreen.style.display = 'none';
            mainContent.style.display = 'flex';
          }, 700);
        }, 500 + wait);
      }
    }
    window.onload = function() {
      loadingStart = Date.now();
      fakeLoading();
    }
    // Profile modal logic
    function openProfile() {
      document.getElementById('profileModal').style.display = 'flex';
      // Load profile if exists
      const p = JSON.parse(localStorage.getItem('profile') || '{}');
      if (p.name) document.getElementById('profileName').value = p.name;
      if (p.age) document.getElementById('profileAge').value = p.age;
      if (p.gender) document.getElementById('profileGender').value = p.gender;
    }
    function closeProfile() {
      document.getElementById('profileModal').style.display = 'none';
    }
    function saveProfile(e) {
      e.preventDefault();
      const name = document.getElementById('profileName').value.trim();
      const age = document.getElementById('profileAge').value;
      const gender = document.getElementById('profileGender').value;
      localStorage.setItem('profile', JSON.stringify({ name, age, gender }));
      closeProfile();
    }
    // Game options modal logic
    function openGameOptions(game, options) {
      document.getElementById('gameOptionsTitle').textContent = game + ' Options';
      const list = document.getElementById('gameOptionsList');
      list.innerHTML = '';
      if(game==='Tic Tac Toe') {
        // Show difficulty selection with arrow bar
        let idx = 0;
        const diffs = ['Easy','Medium','Hard'];
        const diffDiv = document.createElement('div');
        diffDiv.innerHTML = `<h3>Select AI Difficulty</h3><div style='display:flex;align-items:center;justify-content:center;gap:10px;'><button id='leftArr' style='font-size:1.5rem;'>&larr;</button><span id='diffLabel' style='font-size:1.2rem;width:90px;display:inline-block;text-align:center;'>${diffs[idx]}</span><button id='rightArr' style='font-size:1.5rem;'>&rarr;</button></div>`;
        const playBtn = document.createElement('button');
        playBtn.textContent = 'Play AI';
        playBtn.style = 'margin:18px 0 0 0;padding:10px 30px;font-size:1.1rem;background:var(--accent);color:#23243a;border:none;border-radius:8px;cursor:pointer;display:block;width:80%;max-width:260px;';
        playBtn.onclick = () => { closeGameOptions(); startTicTacToe('Single Player', diffs[idx]); };
        diffDiv.appendChild(playBtn);
        const btn2p = document.createElement('button');
        btn2p.textContent = 'Multiplayer';
        btn2p.style = 'margin:10px 0;padding:10px 30px;font-size:1.1rem;background:var(--accent);color:#23243a;border:none;border-radius:8px;cursor:pointer;display:block;width:80%;max-width:260px;';
        btn2p.onclick = () => { closeGameOptions(); startTicTacToe('Multiplayer'); };
        diffDiv.appendChild(btn2p);
        list.appendChild(diffDiv);
        setTimeout(()=>{
          document.getElementById('leftArr').onclick = ()=>{ idx=(idx+diffs.length-1)%diffs.length; document.getElementById('diffLabel').textContent=diffs[idx]; };
          document.getElementById('rightArr').onclick = ()=>{ idx=(idx+1)%diffs.length; document.getElementById('diffLabel').textContent=diffs[idx]; };
        },10);
      }
      document.getElementById('gameOptionsModal').style.display = (game==='Tic Tac Toe') ? 'flex' : 'none';
      if(game==='Tic Tac Toe') return;
    }
    function closeGameOptions() {
      document.getElementById('gameOptionsModal').style.display = 'none';
    }
    // Game logic for all games
    function showGameModal(html) {
      document.getElementById('gameModalContent').innerHTML = '<button onclick="closeGameModal()" style="position:absolute;top:10px;right:18px;background:none;border:none;color:#fff;font-size:1.5rem;cursor:pointer;">&times;</button>' + html;
      document.getElementById('gameModal').style.display = 'flex';
    }
    function closeGameModal() {
      document.getElementById('gameModal').style.display = 'none';
    }
    // Tic Tac Toe with difficulty selection
    function startTicTacToe(mode, difficulty) {
      let board = Array(9).fill('');
      let turn = 'X';
      let ai = (mode === 'Single Player');
      let over = false;
      function render() {
        let html = `<h2>Tic Tac Toe (${mode}${difficulty?(' - '+difficulty):''})</h2><div style='display:grid;grid-template-columns:repeat(3,60px);gap:8px;justify-content:center;margin:20px auto;'>`;
        for(let i=0;i<9;i++) {
          html += `<button onclick='window.tttMove(${i})' style='width:60px;height:60px;font-size:2rem;background:#23243a;color:#fff;border-radius:8px;border:2px solid #444;'>${board[i]}</button>`;
        }
        html += `</div><div id='tttStatus' style='margin:10px 0 0 0;'></div>`;
        showGameModal(html);
        document.getElementById('tttStatus').textContent = over ? (winnerMsg() || 'Draw!') : (turn+"'s turn");
      }
      function winnerMsg() {
        const win = checkWin();
        if(win) return win+" wins!";
        if(board.every(x=>x)) return 'Draw!';
        return '';
      }
      function checkWin() {
        const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
        for(const [a,b,c] of lines) if(board[a]&&board[a]===board[b]&&board[a]===board[c]) return board[a];
        return null;
      }
      window.tttMove = function(i) {
        if(over||board[i]) return;
        board[i]=turn;
        over = !!checkWin() || board.every(x=>x);
        turn = (turn==='X'?'O':'X');
        render();
        if(ai&&!over&&turn==='O') setTimeout(aiMove,400);
      }
      function aiMove() {
        let move;
        if(difficulty==='Easy') {
          let empty = board.map((v,i)=>v?'':i).filter(x=>x!=='')
          move = empty[Math.floor(Math.random()*empty.length)];
        } else if(difficulty==='Medium') {
          // Block win or pick random
          let empty = board.map((v,i)=>v?'':i).filter(x=>x!=='')
          move = empty[Math.floor(Math.random()*empty.length)];
          for(let i of empty) {
            board[i]='O';
            if(checkWin()==='O') { move=i; board[i]=''; break; }
            board[i]='';
          }
        } else if(difficulty==='Hard') {
          // Minimax AI, but 2% chance to make a random move
          if(Math.random()<0.02) {
            let empty = board.map((v,i)=>v?'':i).filter(x=>x!=='')
            move = empty[Math.floor(Math.random()*empty.length)];
          } else {
            move = bestMove(board, 'O');
          }
        }
        window.tttMove(move);
      }
      function bestMove(b, player) {
        let bestScore = -Infinity, move = null;
        for(let i=0;i<9;i++) {
          if(!b[i]) {
            b[i]=player;
            let score = minimax(b, 0, false);
            b[i]='';
            if(score>bestScore) { bestScore=score; move=i; }
          }
        }
        return move;
      }
      function minimax(b, depth, isMax) {
        let winner = checkWinBoard(b);
        if(winner==='O') return 100-depth;
        if(winner==='X') return -100+depth;
        if(b.every(x=>x)) return 0;
        if(isMax) {
          let best = -Infinity;
          for(let i=0;i<9;i++) if(!b[i]) { b[i]='O'; best=Math.max(best,minimax(b,depth+1,false)); b[i]=''; }
          return best;
        } else {
          let best = Infinity;
          for(let i=0;i<9;i++) if(!b[i]) { b[i]='X'; best=Math.min(best,minimax(b,depth+1,true)); b[i]=''; }
          return best;
        }
      }
      function checkWinBoard(b) {
        const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
        for(const [a,b1,c] of lines) if(b[a]&&b[a]===b[b1]&&b[a]===b[c]) return b[a];
        return null;
      }
      render();
    }
    // --- Ludo Board (2P, basic real movement) ---
    function startLudoBoard() {
      // 2 player, 1 token each, simple home-to-home
      let positions = [0,0]; // 0=start, 57=home
      let turn = 0;
      let dice = 1;
      let over = false;
      function render() {
        let html = `<h2>Ludo (2 Player)</h2><div style='display:flex;justify-content:center;gap:40px;margin:20px 0;'>`;
        for(let p=0;p<2;p++) {
          html += `<div><div style='font-weight:bold;margin-bottom:6px;'>Player ${p+1}</div><div style='width:60px;height:60px;border-radius:50%;background:${p===0?'#ffb347':'#9ec1ff'};display:flex;align-items:center;justify-content:center;font-size:2.2rem;margin-bottom:8px;'>${positions[p]===57?'üè†':'üî¥'}</div><div>Pos: ${positions[p]}</div></div>`;
        }
        html += `</div><div style='margin:18px 0;'><button onclick='window.ludoRollReal()' style='padding:10px 30px;font-size:1.1rem;background:var(--accent);color:#23243a;border:none;border-radius:8px;cursor:pointer;'>Roll Dice (Player ${turn+1})</button></div><div id='ludoDice' style='font-size:1.5rem;margin-bottom:10px;'>Dice: ${dice}</div><div id='ludoStatus'></div>`;
        showGameModal(html);
        if(over) document.getElementById('ludoStatus').textContent = `Player ${turn+1} wins!`;
      }
      window.ludoRollReal = function() {
        if(over) return;
        dice = Math.floor(Math.random()*6)+1;
        if(positions[turn]===0 && dice!==6) {
          document.getElementById('ludoStatus').textContent = 'Need 6 to start!';
        } else {
          if(positions[turn]===0 && dice===6) positions[turn]=1;
          else if(positions[turn]>0 && positions[turn]+dice<=57) positions[turn]+=dice;
          if(positions[turn]===57) over=true;
          turn = over?turn:(turn+1)%2;
          render();
        }
        document.getElementById('ludoDice').textContent = 'Dice: '+dice;
      }
      render();
    }
    // --- Memory Game (10 pairs, 20 cards) ---
    function startMemoryGame() {
      let cards = ['üöó','üöô','üöï','üöì','üèéÔ∏è','üöë','üöí','üöö','üöõ','üöú'];
      let deck = cards.concat(cards).sort(()=>Math.random()-0.5);
      let open = [], matched = [];
      let viewing = false;
      function render() {
        let html = `<h2>Memory Game</h2>`;
        html += `<button id='viewAllBtn' style='margin-bottom:10px;padding:4px 18px;font-size:1rem;background:var(--accent);color:#23243a;border:none;border-radius:8px;cursor:pointer;'>View</button>`;
        html += `<div style='display:grid;grid-template-columns:repeat(5,50px);gap:8px;justify-content:center;margin:10px auto 20px auto;'>`;
        for(let i=0;i<20;i++) {
          let show = matched.includes(i)||open.includes(i)||viewing;
          html += `<button onclick='window.memoryFlip(${i})' style='width:50px;height:50px;font-size:2rem;background:#23243a;color:#fff;border-radius:8px;border:2px solid #444;'>${show?deck[i]:''}</button>`;
        }
        html += `</div><div id='memoryStatus' style='margin:10px 0 0 0;'></div>`;
        showGameModal(html);
        document.getElementById('viewAllBtn').onclick = function() {
          if(viewing) return;
          viewing = true;
          render();
          setTimeout(()=>{ viewing = false; render(); }, 2000);
        };
        if(matched.length===20) document.getElementById('memoryStatus').textContent = 'You Win!';
      }
      window.memoryFlip = function(i) {
        if(open.length===2||matched.includes(i)||open.includes(i)||viewing) return;
        open.push(i);
        render();
        if(open.length===2) {
          setTimeout(()=>{
            if(deck[open[0]]===deck[open[1]]) matched.push(...open);
            open=[]; render();
          },700);
        }
      }
      render();
    }
    // --- Math Quiz (AI Mode Selection) ---
    function openMathQuizOptions() {
      showGameModal(`<h2>Math Quiz</h2><div style='margin:18px 0;'>Choose AI Mode:</div><button onclick='startMathQuiz("Easy")' style='margin:8px 0;padding:10px 30px;font-size:1.1rem;background:var(--accent);color:#23243a;border:none;border-radius:8px;cursor:pointer;'>Easy (Single Operation)</button><br><button onclick='startMathQuiz("Medium")' style='margin:8px 0;padding:10px 30px;font-size:1.1rem;background:var(--accent);color:#23243a;border:none;border-radius:8px;cursor:pointer;'>Medium (Two Operations)</button><br><button onclick='startMathQuiz("Hard")' style='margin:8px 0;padding:10px 30px;font-size:1.1rem;background:var(--accent);color:#23243a;border:none;border-radius:8px;cursor:pointer;'>Hard (Three Operations, BODMAS)</button>`);
    }
    function startMathQuiz(mode) {
      let score=0, q=0, a=0;
      function newQ() {
        let question, correct;
        if(mode==="Easy") {
          // Only one operation
          let ops = ['+','-','*'];
          let op = ops[Math.floor(Math.random()*ops.length)];
          let n1 = Math.floor(Math.random()*50+1), n2 = Math.floor(Math.random()*50+1);
          if(op==='*') { n1 = Math.floor(Math.random()*20+2); n2 = Math.floor(Math.random()*12+2); }
          question = `${n1} ${op==='*'?'√ó':op} ${n2}`;
          correct = op==='+'?n1+n2:op==='-'?n1-n2:n1*n2;
        } else if(mode==="Medium") {
          // Two operations, e.g., a + b - c, a + b * c, a - b * c
          let ops = [['+','-'],['+','*'],['-','*']][Math.floor(Math.random()*3)];
          let n1 = Math.floor(Math.random()*30+1), n2 = Math.floor(Math.random()*30+1), n3 = Math.floor(Math.random()*30+1);
          if(ops.includes('*')) { n2 = Math.floor(Math.random()*12+2); n3 = Math.floor(Math.random()*12+2); }
          question = `${n1} ${ops[0]==='*'?'√ó':ops[0]} ${n2} ${ops[1]==='*'?'√ó':ops[1]} ${n3}`;
          // BODMAS: multiplication before addition/subtraction
          if(ops[1]==='*') correct = ops[0]==='+'?n1+n2*n3:n1-n2*n3;
          else correct = ops[0]==='+'?n1+n2-n3:n1-n2+n3;
        } else if(mode==="Hard") {
          // Three operations, e.g., a + b - c * d, a * b + c - d, etc. Use BODMAS
          let n1 = Math.floor(Math.random()*20+1), n2 = Math.floor(Math.random()*20+1), n3 = Math.floor(Math.random()*20+1), n4 = Math.floor(Math.random()*20+1);
          let ops = ['+','-','*'];
          // Randomize order
          let op1 = ops[Math.floor(Math.random()*3)];
          let op2 = ops[Math.floor(Math.random()*3)];
          let op3 = ops[Math.floor(Math.random()*3)];
          // For multiplication, keep numbers smaller
          if(op1==='*') { n1 = Math.floor(Math.random()*12+2); n2 = Math.floor(Math.random()*12+2); }
          if(op2==='*') { n2 = Math.floor(Math.random()*12+2); n3 = Math.floor(Math.random()*12+2); }
          if(op3==='*') { n3 = Math.floor(Math.random()*12+2); n4 = Math.floor(Math.random()*12+2); }
          question = `${n1} ${op1==='*'?'√ó':op1} ${n2} ${op2==='*'?'√ó':op2} ${n3} ${op3==='*'?'√ó':op3} ${n4}`;
          // Evaluate using BODMAS
          let expr = [n1,op1,n2,op2,n3,op3,n4];
          // First, handle all multiplications
          let arr = [];
          for(let i=0;i<expr.length;i++) arr.push(expr[i]);
          for(let i=1;i<arr.length-1;i+=2) {
            if(arr[i]==='*') {
              let res = arr[i-1]*arr[i+1];
              arr.splice(i-1,3,res);
              i-=2;
            }
          }
          // Then, left to right for + and -
          correct = arr[0];
          for(let i=1;i<arr.length;i+=2) {
            if(arr[i]==='+') correct += arr[i+1];
            else if(arr[i]=== '-') correct -= arr[i+1];
          }
        }
        a = correct;
        // Generate four options: one correct, three wrong
        let options = [correct];
        let used = new Set([correct]);
        while(options.length < 4) {
          let delta = Math.floor(Math.random()*13)+1;
          let wrong = Math.random()<0.5 ? correct+delta : correct-delta;
          if(!used.has(wrong) && wrong >= 0) {
            options.push(wrong);
            used.add(wrong);
          }
        }
        options = options.sort(()=>Math.random()-0.5);
        let html = `<h2>Math Quiz (${mode})</h2><div style='margin:20px 0;'>Q${q+1}: ${question} = ?</div>`;
        for(let i=0;i<4;i++) {
          html += `<button onclick='window.checkMathOption(${options[i]})' style='margin:8px 10px 8px 0;padding:8px 22px;font-size:1.1rem;background:var(--accent);color:#23243a;border:none;border-radius:8px;cursor:pointer;'>${options[i]}</button>`;
        }
        html += `<div id='mathStatus' style='margin:10px 0 0 0;'></div><div>Score: <span id='mathScore'>${score}</span></div>`;
        showGameModal(html);
      }
      window.checkMathOption = function(val) {
        if(Math.abs(val-a)<0.0001) { score++; q++; newQ(); }
        else document.getElementById('mathStatus').textContent = 'Wrong! Try again.';
        document.getElementById('mathScore').textContent = score;
      }
      newQ();
    }
    // Chess (full real chess game with check, checkmate, stalemate, castling, pawn promotion, en passant, and random token mix)
    function startChess() {
      // Use chess.js logic (embedded, not external)
      // --- Minimal chess.js logic for rules ---
      // Use standard chess starting order, all tokens visible
      function standardBoard() {
        return [
          ['r','n','b','q','k','b','n','r'],
          ['p','p','p','p','p','p','p','p'],
          ['','','','','','','',''],
          ['','','','','','','',''],
          ['','','','','','','',''],
          ['','','','','','','',''],
          ['P','P','P','P','P','P','P','P'],
          ['R','N','B','Q','K','B','N','R']
        ];
      }
      let board = standardBoard();
      let turn = 'w';
      let selected = null;
      let promotion = null;
      let castling = {w: {K: true, Q: true}, b: {K: true, Q: true}};
      let enPassant = null;
      let halfmove = 0, fullmove = 1;
      let lastMove = null;
      const pieceUnicode = {
        'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
        'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
      };
      function isWhite(piece) { return /[A-Z]/.test(piece); }
      function isBlack(piece) { return /[a-z]/.test(piece); }
      function legalMoves(from) {
        // Returns array of [i,j] for legal moves for piece at from
        let [x,y] = from;
        let piece = board[x][y];
        if(!piece) return [];
        let moves = [];
        let dirs, i, j;
        if(/[Pp]/.test(piece)) {
          let dir = isWhite(piece)?-1:1;
          let startRow = isWhite(piece)?6:1;
          // Forward
          if(board[x+dir]&&board[x+dir][y]==='') moves.push([x+dir,y]);
          // Double move
          if(x===startRow&&board[x+dir]&&board[x+dir][y]===''&&board[x+2*dir][y]==='') moves.push([x+2*dir,y]);
          // Captures
          for(let dy of [-1,1]) {
            if(board[x+dir]&&board[x+dir][y+dy]&&((isWhite(piece)&&isBlack(board[x+dir][y+dy]))||(isBlack(piece)&&isWhite(board[x+dir][y+dy])))) moves.push([x+dir,y+dy]);
            // En passant
            if(enPassant&&x+dir===enPassant[0]&&y+dy===enPassant[1]) moves.push([x+dir,y+dy]);
          }
        } else if(/[Nn]/.test(piece)) {
          let knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
          for(let [dx,dy] of knightMoves) {
            i=x+dx;j=y+dy;
            if(i>=0&&i<8&&j>=0&&j<8&&(!board[i][j]||((isWhite(piece)&&isBlack(board[i][j]))||(isBlack(piece)&&isWhite(board[i][j]))))) moves.push([i,j]);
          }
        } else if(/[Bb]/.test(piece)) {
          dirs = [[-1,-1],[-1,1],[1,-1],[1,1]];
          for(let [dx,dy] of dirs) {
            i=x+dx;j=y+dy;
            while(i>=0&&i<8&&j>=0&&j<8) {
              if(board[i][j]) { if(((isWhite(piece)&&isBlack(board[i][j]))||(isBlack(piece)&&isWhite(board[i][j])))) moves.push([i,j]); break; }
              moves.push([i,j]); i+=dx;j+=dy;
            }
          }
        } else if(/[Rr]/.test(piece)) {
          dirs = [[-1,0],[1,0],[0,-1],[0,1]];
          for(let [dx,dy] of dirs) {
            i=x+dx;j=y+dy;
            while(i>=0&&i<8&&j>=0&&j<8) {
              if(board[i][j]) { if(((isWhite(piece)&&isBlack(board[i][j]))||(isBlack(piece)&&isWhite(board[i][j])))) moves.push([i,j]); break; }
              moves.push([i,j]); i+=dx;j+=dy;
            }
          }
        } else if(/[Qq]/.test(piece)) {
          dirs = [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]];
          for(let [dx,dy] of dirs) {
            i=x+dx;j=y+dy;
            while(i>=0&&i<8&&j>=0&&j<8) {
              if(board[i][j]) { if(((isWhite(piece)&&isBlack(board[i][j]))||(isBlack(piece)&&isWhite(board[i][j])))) moves.push([i,j]); break; }
              moves.push([i,j]); i+=dx;j+=dy;
            }
          }
        } else if(/[Kk]/.test(piece)) {
          for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++) {
            if(dx===0&&dy===0) continue;
            i=x+dx;j=y+dy;
            if(i>=0&&i<8&&j>=0&&j<8&&(!board[i][j]||((isWhite(piece)&&isBlack(board[i][j]))||(isBlack(piece)&&isWhite(board[i][j]))))) moves.push([i,j]);
          }
          // Castling (not full check logic)
          if(isWhite(piece)&&x===7&&y===4) {
            if(castling.w.K&&board[7][5]===''&&board[7][6]==='') moves.push([7,6]);
            if(castling.w.Q&&board[7][3]===''&&board[7][2]===''&&board[7][1]==='') moves.push([7,2]);
          }
          if(isBlack(piece)&&x===0&&y===4) {
            if(castling.b.K&&board[0][5]===''&&board[0][6]==='') moves.push([0,6]);
            if(castling.b.Q&&board[0][3]===''&&board[0][2]===''&&board[0][1]==='') moves.push([0,2]);
          }
        }
        return moves.filter(([i,j])=>i>=0&&i<8&&j>=0&&j<8);
      }
      function isCheck(turnColor, customBoard) {
        // Find king
        let king = turnColor==='w'?'K':'k';
        let kx=-1,ky=-1;
        let b = customBoard || board;
        for(let i=0;i<8;i++) for(let j=0;j<8;j++) if(b[i][j]===king) { kx=i;ky=j; }
        // See if any enemy piece attacks king
        for(let i=0;i<8;i++) for(let j=0;j<8;j++) {
          let p=b[i][j];
          if(!p||(turnColor==='w'?isWhite(p):isBlack(p))) continue;
          let moves=legalMoves([i,j], b);
          for(let [mi,mj] of moves) if(mi===kx&&mj===ky) return true;
        }
        return false;
      }
      function legalMoves(from, customBoard) {
        // Returns array of [i,j] for legal moves for piece at from
        let [x,y] = from;
        let b = customBoard || board;
        let piece = b[x][y];
        if(!piece) return [];
        let moves = [];
        let dirs, i, j;
        if(/[Pp]/.test(piece)) {
          let dir = isWhite(piece)?-1:1;
          let startRow = isWhite(piece)?6:1;
          // Forward
          if(board[x+dir]&&board[x+dir][y]==='') moves.push([x+dir,y]);
          // Double move
          if(x===startRow&&board[x+dir]&&board[x+dir][y]===''&&board[x+2*dir][y]==='') moves.push([x+2*dir,y]);
          // Captures
          for(let dy of [-1,1]) {
            if(board[x+dir]&&board[x+dir][y+dy]&&((isWhite(piece)&&isBlack(board[x+dir][y+dy]))||(isBlack(piece)&&isWhite(board[x+dir][y+dy])))) moves.push([x+dir,y+dy]);
            // En passant
            if(enPassant&&x+dir===enPassant[0]&&y+dy===enPassant[1]) moves.push([x+dir,y+dy]);
          }
        } else if(/[Nn]/.test(piece)) {
          let knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
          for(let [dx,dy] of knightMoves) {
            i=x+dx;j=y+dy;
            if(i>=0&&i<8&&j>=0&&j<8&&(!b[i][j]||((isWhite(piece)&&isBlack(b[i][j]))||(isBlack(piece)&&isWhite(b[i][j]))))) moves.push([i,j]);
          }
        } else if(/[Bb]/.test(piece)) {
          dirs = [[-1,-1],[-1,1],[1,-1],[1,1]];
          for(let [dx,dy] of dirs) {
            i=x+dx;j=y+dy;
            while(i>=0&&i<8&&j>=0&&j<8) {
              if(b[i][j]) { if(((isWhite(piece)&&isBlack(b[i][j]))||(isBlack(piece)&&isWhite(b[i][j])))) moves.push([i,j]); break; }
              moves.push([i,j]); i+=dx;j+=dy;
            }
          }
        } else if(/[Rr]/.test(piece)) {
          dirs = [[-1,0],[1,0],[0,-1],[0,1]];
          for(let [dx,dy] of dirs) {
            i=x+dx;j=y+dy;
            while(i>=0&&i<8&&j>=0&&j<8) {
              if(b[i][j]) { if(((isWhite(piece)&&isBlack(b[i][j]))||(isBlack(piece)&&isWhite(b[i][j])))) moves.push([i,j]); break; }
              moves.push([i,j]); i+=dx;j+=dy;
            }
          }
        } else if(/[Qq]/.test(piece)) {
          dirs = [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]];
          for(let [dx,dy] of dirs) {
            i=x+dx;j=y+dy;
            while(i>=0&&i<8&&j>=0&&j<8) {
              if(b[i][j]) { if(((isWhite(piece)&&isBlack(b[i][j]))||(isBlack(piece)&&isWhite(b[i][j])))) moves.push([i,j]); break; }
              moves.push([i,j]); i+=dx;j+=dy;
            }
          }
        } else if(/[Kk]/.test(piece)) {
          for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++) {
            if(dx===0&&dy===0) continue;
            i=x+dx;j=y+dy;
            if(i>=0&&i<8&&j>=0&&j<8&&(!b[i][j]||((isWhite(piece)&&isBlack(b[i][j]))||(isBlack(piece)&&isWhite(b[i][j]))))) moves.push([i,j]);
          }
          // Castling (not full check logic)
          if(isWhite(piece)&&x===7&&y===4) {
            if(castling.w.K&&b[7][5]===''&&b[7][6]==='') moves.push([7,6]);
            if(castling.w.Q&&b[7][3]===''&&b[7][2]===''&&b[7][1]==='') moves.push([7,2]);
          }
          if(isBlack(piece)&&x===0&&y===4) {
            if(castling.b.K&&b[0][5]===''&&b[0][6]==='') moves.push([0,6]);
            if(castling.b.Q&&b[0][3]===''&&b[0][2]===''&&b[0][1]==='') moves.push([0,2]);
          }
        }
        return moves.filter(([i,j])=>i>=0&&i<8&&j>=0&&j<8);
      }
      function getAllLegalMovesFiltered() {
        // If in check, only allow moves that resolve check
        let moves = [];
        let color = turn;
        let isInCheck = isCheck(color);
        for(let i=0;i<8;i++) for(let j=0;j<8;j++) {
          let piece = board[i][j];
          if(!piece) continue;
          if((color==='w'&&isWhite(piece))||(color==='b'&&isBlack(piece))) {
            let pieceMoves = legalMoves([i,j]);
            for(let [mi,mj] of pieceMoves) {
              // Simulate move
              let bcopy = board.map(row=>row.slice());
              bcopy[mi][mj] = bcopy[i][j];
              bcopy[i][j] = '';
              if(!isCheck(color, bcopy)) {
                moves.push({from:[i,j],to:[mi,mj]});
              }
            }
          }
        }
        return moves;
      }
      function render() {
        // Check if either king is missing (game over)
        let whiteKing = false, blackKing = false;
        for(let i=0;i<8;i++) for(let j=0;j<8;j++) {
          if(board[i][j]==='K') whiteKing = true;
          if(board[i][j]==='k') blackKing = true;
        }
        let gameOver = !whiteKing || !blackKing;
        let html = `<h2>Chess (Standard Start)</h2><div style='display:grid;grid-template-columns:repeat(8,40px);gap:0;justify-content:center;margin:20px auto;border:2px solid #fff;border-radius:8px;'>`;
        let checkSquares = [];
        if(!gameOver) {
          // Highlight king in check
          let kingPos = null;
          let kingChar = turn==='w'?'K':'k';
          for(let i=0;i<8;i++) for(let j=0;j<8;j++) if(board[i][j]===kingChar) kingPos = [i,j];
          if(kingPos && isCheck(turn)) checkSquares = [kingPos];
        }
        for(let i=0;i<8;i++) for(let j=0;j<8;j++) {
          let piece = board[i][j];
          let sel = selected&&selected[0]===i&&selected[1]===j;
          let isWhiteSq = (i+j)%2===0;
          let bg = sel ? '#ffb347' : (isWhiteSq ? '#fff' : '#23243a');
          let color = piece ? (isWhite(piece)?'#1e90ff':'#d7263d') : (isWhiteSq?'#23243a':'#fff');
          let highlight = '';
          if(selected) {
            let moves = legalMoves(selected);
            for(let [mi,mj] of moves) if(mi===i&&mj===j) highlight = 'box-shadow:0 0 0 3px #ffb347 inset;';
          }
          if(lastMove && lastMove.to[0]===i && lastMove.to[1]===j) highlight += 'outline:2px solid #2ecc40;';
          if(checkSquares.some(([ci,cj])=>ci===i&&cj===j)) highlight += 'box-shadow:0 0 0 3px #ff2222 inset;';
          html += `<button onclick='window.chessClick(${i},${j})' style='width:40px;height:40px;font-size:1.5rem;background:${bg};color:${color};border:none;${highlight}display:flex;align-items:center;justify-content:center;'${gameOver?' disabled':''}>${piece?pieceUnicode[piece]:''}</button>`;
        }
        html += `</div><div id='chessStatus' style='margin:10px 0 0 0;'>`;
        if(gameOver) {
          html += (!whiteKing ? "Black" : "White") + " wins! (King captured)";
        } else {
          html += `${turn==="w"?"White's":"Black's"} turn${isCheck(turn)?' - <span style=\'color:#ff2222;font-weight:bold\'>Check!</span>':''}`;
        }
        html += `</div>`;
        showGameModal(html);
      }
      window.chessClick = function(i,j) {
        if(promotion) return;
        // Prevent moves after king is captured
        let whiteKing = false, blackKing = false;
        for(let x=0;x<8;x++) for(let y=0;y<8;y++) {
          if(board[x][y]==='K') whiteKing = true;
          if(board[x][y]==='k') blackKing = true;
        }
        if(!whiteKing || !blackKing) return;
        let piece = board[i][j];
        // Only allow moves that resolve check if in check
        let color = turn;
        let isInCheck = isCheck(color);
        let allowedMoves = getAllLegalMovesFiltered();
        if(selected) {
          let [si,sj]=selected;
          let moves = legalMoves([si,sj]);
          // Filter moves if in check
          if(isInCheck) {
            moves = moves.filter(([mi,mj])=>allowedMoves.some(m=>m.from[0]===si&&m.from[1]===sj&&m.to[0]===mi&&m.to[1]===mj));
          }
          let valid = moves.some(([mi,mj])=>mi===i&&mj===j);
          // Prevent moving to/capturing own piece
          if(valid && (!board[i][j] || (isWhite(board[si][sj])!==isWhite(board[i][j])))) {
            // Handle castling
            if(/[Kk]/.test(board[si][sj])&&Math.abs(j-sj)===2) {
              // King-side
              if(j>sj) { board[i][5]=board[i][7]; board[i][7]=''; }
              // Queen-side
              else { board[i][3]=board[i][0]; board[i][0]=''; }
            }
            // Handle en passant
            if(/[Pp]/.test(board[si][sj])&&sj!==j&&board[i][j]=='') {
              board[si][j]='';
            }
            // Move
            let prev = board[i][j];
            board[i][j]=board[si][sj];
            board[si][sj]='';
            lastMove = {from:[si,sj],to:[i,j],captured:prev};
            // Pawn promotion
            if(/[Pp]/.test(board[i][j])&&((isWhite(board[i][j])&&i===0)||(isBlack(board[i][j])&&i===7))) {
              promotion = {i,j,color:isWhite(board[i][j])?'w':'b'};
              render();
              setTimeout(()=>{
                let opts = promotion.color==='w'?['Q','R','B','N']:['q','r','b','n'];
                let html = `<h3>Promote Pawn</h3>`;
                for(let o of opts) html += `<button onclick='window.promotePawn("${o}")' style='margin:8px 8px 0 0;padding:8px 18px;font-size:1.1rem;background:var(--accent);color:#23243a;border:none;border-radius:8px;cursor:pointer;'>${pieceUnicode[o]}</button>`;
                document.getElementById('gameModalContent').innerHTML += `<div style='margin-top:18px;'>${html}</div>`;
              },100);
              return;
            }
            // Switch turn
            turn = turn==='w'?'b':'w';
            selected=null; promotion=null;
            render();
            return;
          } else if(piece&&((turn==='w'&&isWhite(piece))||(turn==='b'&&isBlack(piece)))) {
            selected=[i,j]; render();
          } else {
            selected=null; render();
          }
        } else if(piece&&((turn==='w'&&isWhite(piece))||(turn==='b'&&isBlack(piece)))) {
          // Only allow selecting pieces that have at least one legal move (and, if in check, only those that can resolve check)
          let moves = legalMoves([i,j]);
          if(isInCheck) {
            moves = moves.filter(([mi,mj])=>allowedMoves.some(m=>m.from[0]===i&&m.from[1]===j&&m.to[0]===mi&&m.to[1]===mj));
          }
          if(moves.length>0) {
            selected=[i,j]; render();
          }
        }
      }
      window.promotePawn = function(o) {
        if(promotion) {
          board[promotion.i][promotion.j]=o;
          promotion=null;
          turn = turn==='w'?'b':'w';
          render();
        }
      }
      render();
    }
    // --- Sliding Number Puzzle (AI Mode Selection) ---
    function openSlidingPuzzleOptions() {
      showGameModal(`<h2>Sliding Number Puzzle</h2><div style='margin:18px 0;'>Choose AI Mode:</div><button onclick='startSlidingPuzzle("Easy")' style='margin:8px 0;padding:10px 30px;font-size:1.1rem;background:var(--accent);color:#23243a;border:none;border-radius:8px;cursor:pointer;'>Easy (1-8)</button><br><button onclick='startSlidingPuzzle("Medium")' style='margin:8px 0;padding:10px 30px;font-size:1.1rem;background:var(--accent);color:#23243a;border:none;border-radius:8px;cursor:pointer;'>Medium (1-15)</button><br><button onclick='startSlidingPuzzle("Hard")' style='margin:8px 0;padding:10px 30px;font-size:1.1rem;background:var(--accent);color:#23243a;border:none;border-radius:8px;cursor:pointer;'>Hard (1-24)</button>`);
    }
    function startSlidingPuzzle(mode) {
      let size, maxNum;
      if(mode==="Easy") { size=3; maxNum=8; }
      else if(mode==="Medium") { size=4; maxNum=15; }
      else if(mode==="Hard") { size=5; maxNum=24; } // 5x5, 1-24 numbers, 1 empty
      else { size=4; maxNum=15; }
      let total=size*size;
      let nums = [...Array(maxNum).keys()].map(x=>x+1);
      let board = shuffle(nums.concat(Array(total-nums.length).fill('')));
      let moves = 0;
      let timer = 0;
      let interval = null;
      let solving = false;
      function shuffle(arr) {
        let a = arr.slice();
        do {
          for(let i=a.length-1;i>0;i--) {
            let j = Math.floor(Math.random()*(i+1));
            [a[i],a[j]] = [a[j],a[i]];
          }
        } while(!isSolvable(a));
        return a;
      }
      function isSolvable(b) {
        let inv = 0;
        for(let i=0;i<b.length-1;i++) for(let j=i+1;j<b.length;j++) if(b[i]&&b[j]&&b[i]>b[j]) inv++;
        let row = Math.floor(b.indexOf('')/size);
        return ((inv+row)%2===0);
      }
      function render() {
        let html = `<h2>Sliding Number Puzzle (${mode})</h2>`;
        html += `<div style='display:grid;grid-template-columns:repeat(${size},50px);gap:8px;justify-content:center;margin:10px auto 20px auto;'>`;
        for(let i=0;i<total;i++) {
          html += `<button onclick='window.slideMove(${i})' style='width:50px;height:50px;font-size:1.3rem;background:${board[i]===''?'#444':'#23243a'};color:#fff;border-radius:8px;border:2px solid #444;' ${solving?'disabled':''}>${board[i]}</button>`;
        }
        html += `</div><div style='margin:10px 0;'>Moves: <span id='slideMoves'>${moves}</span> | Time: <span id='slideTime'>${formatTime(timer)}</span></div><div id='slideStatus'></div>`;
        showGameModal(html);
        if(isSolved()) {
          clearInterval(interval);
          document.getElementById('slideStatus').textContent = `Congratulations! You solved it in ${moves} moves and ${formatTime(timer)}.`;
        }
      }
      function isSolved() {
        for(let i=0;i<maxNum;i++) if(board[i]!==i+1) return false;
        for(let i=maxNum;i<total;i++) if(board[i]!=="") return false;
        return true;
      }
      window.slideMove = function(i) {
        if(isSolved()||solving) return;
        let empty = board.indexOf('');
        let canMove = [empty-1,empty+1,empty-size,empty+size].includes(i) &&
          ((Math.floor(i/size)===Math.floor(empty/size))||(i%size===empty%size));
        if(canMove) {
          [board[i],board[empty]] = [board[empty],board[i]];
          moves++;
          render();
        }
      }
      function formatTime(t) {
        let m = Math.floor(t/60), s = t%60;
        return `${m}:${s.toString().padStart(2,'0')}`;
      }
      if(interval) clearInterval(interval);
      timer = 0; moves = 0; solving = false;
      interval = setInterval(()=>{
        if(isSolved()) { clearInterval(interval); return; }
        timer++;
        let el = document.getElementById('slideTime');
        if(el) el.textContent = formatTime(timer);
      },1000);
      render();
    }
    // Hook up direct games
    document.querySelectorAll('.game-cube').forEach(cube => {
      const text = cube.textContent.trim();
      if(text==='Sliding Number Puzzle') cube.onclick = ()=>openSlidingPuzzleOptions();
      if(text==='Memory Game') cube.onclick = ()=>startMemoryGame();
      if(text==='Math Quiz') cube.onclick = ()=>openMathQuizOptions();
      if(text==='Chess') cube.onclick = ()=>startChess();
    });
  </script>
</body>
</html>
